<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="ClearpathPositionLinPPR" Id="{3d5cfdb1-50e3-45e6-8ce6-e6dca8940813}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK ClearpathPositionLinPPR //please check comments inside FB to determine clearpath settings before use
VAR_INPUT
	
	//PI (Program Inputs)
		bHomeStart_PI				: BOOL;		//begin Homing sequence
		PowerOn_PI					: BOOL;		//enable motor command from program
		Stop_PI						: BOOL;		//stop command from program
		DistancePosReq_PI			: REAL;		//distanct position request from the program (input in absolute position and valid after homing)
		ManualMove_PI				: BOOL;		//Call manual move method if true
		Mode_PI						: INT;		//0:noMode, 1:Auto, 2:Manual
		bMove_PI					: BOOL;		//begin absolute move
		VEReq :LREAL;
	//VI (visualization input/hmi input)
		Reset_VI			: BOOL;		//reset button	
		DisReq_VI			: REAL;		//Disreq for absolute auto move	
		JogExecute_VI		: BOOL;		//Call manual move method if true
		SuperJogExecute_VI	: Bool;		//call super manual move method if true
		SuperJogMode_VI		: BOOL;		//Super Mode on if true (changes Jog method) use for overtravel or not homed be Cautious
		JogSlow_VI			: BOOL;		//slow manual move
		CW_VI				: BOOL;		//Set Direction for requested move (does not apply to absolute move) True = Clockwise
	//CI (configuration input)
		IN							: LinPPR_CI;
END_VAR
VAR_OUTPUT
	//Outputs
		Out						: LinPPR_Out;
END_VAR
VAR
	AltSpeedCase		: INT;		//case tracker altspeed()
	AltSpeedReq			: BOOL;		//turn altspeed method on
	ResetCase			: INT; 		//makes a reset instead of an alt speed request (delays the turning off of reset)
	HomeCase			: INT;		//case tracker home()
	JogCase				: INT;		//case tracker Jog()
	SuperJogCase		: INT;		//case tracker SuperJog()
	DisToGoCase			: INT;		//case tracker MoveABSLin() for pulse train que
	PositionCase		: INT;
	SWLimitStatus		: BOOL;		//Used to check if currently within software limits
	testBOol			: BOOL;		//tester
	error				: INT;		//5: increment error
	PulsesEnabled		: BOOL;		//enable absolute move method to command pulses
	busy				: BOOL;		//move in progress
	MoveComplete		: BOOL;		//all ppr accounted for after move command
	PulseCount			: INT;		//current Pulse Count
	expectedPulse		: INT;		//expected pulses from commanded movements at set PPR
	HomeTrig			: R_trig;	//trigger position capture when homing ends
	ATrig				: R_trig;	//counter/trigger to track how many increments of a output have been commanded
	pulseCounter		: r_trig;
	JogRTrig			: R_Trig;	//jog execute trigger
	JogFTrig			: F_Trig;	//Jog Cancel Trigger
	bMoveTrig			: r_trig;
	JogReset			: bool;
	ASG					: BOOL;		//all systems go clearpath (if using asg)
	Cancelled			: BOOL;		//move was cancelled requires reset
	CW					: BOOL; 	//direction of motor rotation: CW is true;  CCW is false;
	DistanceToGo		: REAL;		//difference in distance from current position and requested position.  used to determine linear direction
	isConfigured		: BOOL;		//turns on or off the configuration settings method so it only runs on first scan
	DistPerMRev 		: INT;
	testlimit			: INT;
	testR				: INT;
	DisPerPulse			: INT;		//distance per pulse based on configuration inputs
	PulsesToSend		: INT;		//Pulses to send for Absolute move
	CWABS				: BOOL;		//Direction for abs Move [Check against pulse wrong dir]
	testpulsecnt		: INT;		//testing flot vs int
	PulseQueSet			: BOOL;		//start pulses for move
	PulseQue			: int;		//int counter to hold the number of pulses left to send
	LastDistancePosReq	: real;
	//FI (Field Inputs)

	HLFB_FI	 		AT %I*	: BOOL;		// high level feedback sensors
	bInputBCom_FI	AT %I*	: BOOL;		// check sum for inputb signal	(double check that direction is actually signaled to motor)
	
	//Linear Homing Variables
	bHigh_FI		AT %I*	: BOOL;
	bLow_FI			AT %I*	: BOOL;
	bHome_FI		AT %I*	: BOOL;
	
	//FO (Field Outputs)
	HLFB24V_FO 			AT %Q*	: BOOL :=1;	//high level feedback 24v power if needed to used el2008 //default set to true so that hlfb is fucntional
	EnableOut_FO 		AT %Q* 	: BOOL; 	//enables the clearpath motor
	InputAOut_FO 		AT %Q* 	: BOOL; 	//input A of clearpath motor, output from plc
	InputBOut_FO 		AT %Q* 	: BOOL; 	//input B of clearpath motor, output from plc
	
END_VAR
VAR RETAIN 
	
	
END_VAR

VAR_IN_OUT

END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[(* Checck clearpath settings before use*)
	(* Check the input filter setting for inputA and inputB.   Also check PPR setting, CntsPerPulse, HLFBsetting, and The type of axis,  
		Place clearpath in correct mode of operation Mode for this FB is position 
		Check what Homing setting is used on the clearpath motor	
		check to make sure that the resolution of movement commands matches gearbox compatibiltiy, and plc scan compatability
		
		How the FB works Details:
			1st scan sets configuration using MechDrive_CI()
			Each scan CP motor direction is set based off CW variable
			LocatePosition() drives limit switches and rotary cam limit quadrants
			Pulses are counted using ppr() to move with hlfb rising trig counter.  Expected pulses are tracked with inputA_FO rising trig
			Enable checks for enable signal, cancelled state, and stop_PI state before turning on motor or disenable
			reset: cp motors require an enable off to reset after ac loss...ie estop w/contactor.  it also resets cancelled bit and busy bit (requires reset_vi to run)
			
			Moves are called using homing sequence, Absolute movement, or with manual movement and all require homing.
			after homing absolute movement within software limit_CI is available or manual jog.  Manual jog is set to single pulse method by default
			After Homing Position is tracked using 'DistancePos_PO'
			ABsolute move chains clearpath pulses together to create a smooth motion profile. 
				Pulses sent are tracked against 'DistancePosReq_PI' and 'DistancePos_PO'  When expected pulses are within range of requested position then 'pulsecount' is reset
	*)
(*configruation input setting*)
IF isConfigured = 0 THEN MechDrive_CI();	END_IF	//run once to set configuration on init

//Pin outs Clockwise (CW) or Counter Clockwise (CCW)
IF CW THEN	InputBOut_FO := 1;	ELSE InputBOut_FO := 0; 	END_IF //sets direction of movement at motor - check this (add bcom direction pin check)
LocatePosition();				//rotary position of the cam wheel  //also includes a double sensor check for SensorCheck_PO  //Also locates position for linear system for limit sensors //Limits
//Triggers
	pulseCounter(clk:=HLFB_FI);		//high Level feedback counter based off direction
	HomeTrig(clk:=Out.Homed_PO);		//used in ppr() to set pulses to zero after homing
	ATrig (clk:=InputAOut_FO);		//counts pulses sent to motor (clearpath should move based on InputA Rising Trig (check settings in CP to be sure - options are for rising or falling trig)
	JogRTrig(CLK:=JogExecute_VI);	//Starts Jog()
	JogFTrig(CLK:=JogExecute_VI);	//Cancels Jog() movement
	bMoveTrig(Clk:=bmove_PI,); 		//confirms that move has triggered and then can check MDI MCode Req Pos
IF Mode_PI =2 THEN
	IF SuperJogMode_VI =0 THEN
		Jog(); ELSE SuperJog();
	END_IF
	Out.ModeMsg_VO :='Manual Mode Engaged';
END_IF
IF Mode_PI =1 THEN
	DistancePosReq_PI:=DisReq_vi;
	MoveAbsLin();
END_IF
PPR();							//tracking of the Pulses per revolution if using ppr (default for most use cases)
Home();
//moved movedone into movement manula call and abs move call
MoveDone();						//check if movement is complete (will either check pulses against expected pulses or will check for asg
Enable();						//check for motor enable status and try to enable the motor if PowerOn_PI is true
Reset();						//if reset button turn power off, reset cancelled, and reset busy
IF stop_PI THEN CancelMove(); END_IF	//This requires a reset afterwards to move again
]]></ST>
    </Implementation>
    <Method Name="AltSpeed" Id="{16f43aef-3fb7-4046-8cb1-bdde39e27b96}">
      <Declaration><![CDATA[METHOD PUBLIC AltSpeed : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(*clearpath requires at least a 20ms delay where the enable signal is pulsed off to realize alternate speed *)

//start
CASE AltSpeedCase OF
	0:
		altspeedcase :=10;
	10:
		EnableOut_FO :=1 ;
		AltSpeedCase :=20;
	20:
		EnableOut_FO :=1;
		AltSpeedCase :=30;
	30:
		EnableOut_FO := 0 ;
		AltSpeedCase :=40;
	40:
		EnableOut_FO := 0;
		AltSpeedCase := 50;
	50:
		EnableOut_FO := 0 ;
		AltSpeedCase := 60;
	60:	
		EnableOut_FO := 1 ;
		//Look for 'AltSpeedCase' to be set to '0' in the call function
	
	90: //error or message
END_CASE

]]></ST>
      </Implementation>
    </Method>
    <Method Name="CancelMove" Id="{eab88ea7-cedc-41c6-80ee-6c11b2114efa}">
      <Declaration><![CDATA[METHOD PUBLIC CancelMove : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[EnableOut_FO 	:= 0;		//only way to clear out overstacked increment calls is to turn enable off and then on
//PowerOn_PI		:=0;	//turn off power on [this is a program input and can't be turned off here] check this to see if still needed[was affecting homecase]
Cancelled	:=1;	//cancelled move needs to be reset
expectedpulse := pulsecount;	//resets expected pulse after an estop or limit switch event
Out.DistancePos_PO := Pulsecount/2; //PPRset_CI*1	//resets distance counter to position after a cancelled move
Out.ExpDistancePos_PO := PulseCount/2; //change distancePOs_PO to float if needed
DisToGoCase :=0;
PulsesToSend :=0;
AltSpeedReq :=0;	//clear alt speed mode	
AltSpeedCase :=0;	
InputAOut_FO :=0;
// message (move was canceled)


]]></ST>
      </Implementation>
    </Method>
    <Method Name="DisToGo" Id="{4db4c9e3-83f7-499d-996a-ec751341deff}">
      <Declaration><![CDATA[METHOD PUBLIC DisToGo : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF Out.Homed_PO THEN
	IF DistancePosReq_PI > Out.ExpDistancePos_PO THEN 
		CW := 1;	//move CW to reach req position
	END_IF
	IF DistancePosReq_PI < Out.ExpDistancePos_PO THEN
		CW :=0;	//Move CCW to reach req position
	END_IF
(*	IF PulseQue >0 THEN 
		PulsesEnabled:=1;
		ELSE PulsesEnabled :=0; 
	END_IF *)
	
	IF DistancePosReq_PI = Out.ExpDistancePos_PO THEN 
		PulsesEnabled :=0;
		CW := CW;
		ELSE
			PulsesEnabled := 1;
	END_IF

	ELSE
	//check this (is the homed block required?)
	//Message that Movement cant be made until homing has occured or use manual mode	
	
END_IF

(*
if pulseQue is > 0 then PulseEnabled;
*)]]></ST>
      </Implementation>
    </Method>
    <Method Name="Enable" Id="{6f6aa6ec-6d36-4ff6-9f03-696861add211}">
      <Declaration><![CDATA[METHOD PUBLIC Enable : BOOL 	//attempts to enable the motor based on stop_PI, Cancelled, and PowerOn_PI
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF Stop_PI =0 AND cancelled =0 AND PowerOn_PI =1 AND ResetCase=0 THEN
	EnableOut_FO :=1;
	IF altSpeedReq THEN
		AltSpeed();				//calls altspeed to cycle thru if homing or manual mode requests a slower mode
	END_IF
	ELSE EnableOut_FO :=0;	//message to say stop is on (check this)
END_IF


//power on

//check if asg

//if no asg power off and repeat
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Error" Id="{2be19997-ee1f-477f-b3ca-4784e7eb28b5}">
      <Declaration><![CDATA[METHOD PUBLIC Error : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// if hlfb pulses do not move in set timeframe after movement call then call error for motor
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Home" Id="{9412d20d-33f6-4a76-94a3-54415f5abbb1}">
      <Declaration><![CDATA[METHOD PUBLIC Home : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//limit switch and home switch configuration
IF IN.HomingSet_CI = 2 THEN //homing sensor not used - home to low sensor
bHome_FI := bLow_FI; 
//message homing sensor not used
END_IF
IF IN.HomingSet_CI = 3 THEN //homing sensor not used - home to Hi sensor
	bHome_FI := bHigh_FI; 
	//message homing sensor not used
END_IF
//error catch for if InputBout wire fails and ends up homing unknown direction repeatedly
IF PowerOn_PI = 0 THEN HomeCase :=0; END_IF
IF Stop_PI = 1 THEN HomeCase := 0; END_IF
//check the InputBOut com using EL1008 input channel to determine that the pulse did work
//message
IF bhomestart_PI = 1 THEN HomeCase :=0; AltSpeedReq := 1; AltSpeedCase:=0; END_IF
CASE HomeCase OF
	0://set pulses equal so that movement can begin and check direction
		IF bHomeStart_PI =1 AND Stop_PI = 0  THEN
			HomeCase := 10;
			bhomeStart_PI :=0;
			AltSpeedReq := 1;				//set slow mode and alternate speed in clearpath
			//AltSpeedCase := 0;			//may need this to start slow speed
			ExpectedPulse := PulseCount;	//Make movement available no matter the pulse count discrepancy
			InputAOut_FO :=0;
			Out.Homed_PO :=0;
		END_IF
	(*5:	
		IF Stop_PI = 0  THEN
			HomeCase := 10;
			bhomeStart_PI :=0;
			AltSpeedReq := 1;				//set slow mode and alternate speed in clearpath
			AltSpeedCase := 0;
			ExpectedPulse := PulseCount;	//Make movement available no matter the pulse count discrepancy
			Homed_PO :=0;
		END_IF*)
		
	10:// homing sequence
		IF  Stop_PI = 0  THEN
			Out.Homed_PO :=0;
			//check this: reseting expected to match pulse count so that homeing will start if there is a mismatch
			//decide homing direction and homing method //make flag large enough to hit home switch and the limit switch
			IF IN.Limit_NC_NO_CI =0 THEN	//NC switch configuration
				IF bHigh_FI =1 AND bLow_FI =1 THEN	//using normally closed sensor (flag is not on either limit switch)
					IF IN.HomingSet_CI =2 THEN cw := 0; ELSIF IN.HomingSet_CI =3 THEN cw :=1; END_IF //go to high or low first if no limit switch tripped
				END_IF
			ELSE	//NO switch Configuration
				IF bHigh_FI =0 AND bLow_FI =0 THEN	//using normally closed sensor (flag is not on either limit switch)
					IF IN.HomingSet_CI =2 THEN cw := 0; ELSIF IN.HomingSet_CI =3 THEN cw :=1; END_IF //go to high or low first if no limit switch tripped
				END_IF
			END_IF
			//if inputA is hi then turn off (takes 2 cycles to output an increment at cp motor)
				(*if pulses expected = pulse count then do the next move *)
			IF AltSpeedCase = 60 THEN SendPulse(); END_IF
			IF IN.Limit_NC_NO_CI =0 THEN	//NC switch configuration
				IF bHome_FI =0 THEN //use nc switch for sensor [at home position]
					bHomeStart_PI :=0;
					Cancelmove();
					HomeCase := 20;
				END_IF
				ELSE				//NO switch configuration
				IF bHome_FI =1 THEN //use no switch for sensor [at home position]
				bHomeStart_PI :=0;
				Cancelmove();
				HomeCase := 20;
			END_IF	
			END_IF
			(*check this - add in an extra cycle before setting home that moves away from the 
				homed spot in same direction to confirm trigger positino comes on same side of sensor each time*)
		END_IF
	20:	//extra scan before homed
		HomeCase :=50;	//this scan is required to allow for a cancelled move reset after homing
	
	50://after homing reset motor and cancelled bit
		
			Out.Homed_PO := 1;
			//cancelled :=0;	//resets motor after initial homing
			pulsecount :=0;
			expectedPulse :=0;
			Out.DistancePos_PO :=0;
			Out.ExpDistancePos_PO :=0;
			testbool := TRUE;
			HomeCase := 0;	//back to the start
	90://reset to default or?
	
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="InLimits" Id="{e482dea8-c9cd-4842-975d-1f001c5c248b}">
      <Declaration><![CDATA[METHOD PUBLIC InLimits : BOOL
VAR_INPUT
	Req	: REAL;	//reqested degree or position from abs move to be evaluated for limits
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//only valid after homing
InLimits := TRUE;
IF IN.SWLimit_Hi_CI <=0 OR IN.SWLimit_Lo_CI >=0 THEN		//check this (may need to have a neg hi at some point)
	//message to say no limits are set
	InLimits :=FALSE;	
END_IF
IF Req <= IN.SWLimit_Hi_CI AND Req >= IN.SWLimit_Lo_CI THEN
	InLimits := TRUE;
	ELSE
		InLimits :=FALSE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Jog" Id="{dadf8fbf-7097-4bd5-bd79-292a7b4121e6}">
      <Declaration><![CDATA[METHOD PUBLIC Jog : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
//add software limits check this
CASE JogCase OF 
	0:	//Main Jog Sequence [Also stops movement]
		IF JogSlow_VI THEN AltspeedReq :=1; ELSE AltSpeedReq :=0;   END_IF
			
		IF JogExecute_VI AND Out.Homed_PO =1  THEN	//if last move is done then allow for manual increment also required to be at home //check sensor check
			IF IN.Limit_NC_NO_CI = 0 THEN	//NC limit switch configuration
				IF bHigh_FI AND bLow_FI THEN //set direction via hmi unless on a limit switch then default to locateposition()
					IF CW_VI = 1 	THEN	CW := 1; 	ELSE CW:=0; 	END_IF
					IF bhigh_fI = 0	THEN 	CW:=0; 		END_IF
					IF bLow_FI = 0 	THEN 	CW:=1; 		END_IF
				END_IF
				ELSE	//NO limit switch configuration
					IF bHigh_FI =0 AND bLow_FI  = 0 THEN //set direction via hmi unless on a limit switch then default to locateposition()
					IF CW_VI = 1 	THEN	CW := 1; 	ELSE CW:=0; 	END_IF
					IF bhigh_fI = 1	THEN 	CW:=0; 		END_IF
					IF bLow_FI = 1 	THEN 	CW:=1; 		END_IF
				END_IF
			END_IF
			IF AltspeedReq THEN			// slowjog if altspeed is requested and wait for case 60
				IF AltspeedCase = 60 THEN
					SendPulse();
					
				END_IF
				ELSE
					SendPulse();		//send pulse for reg speed jog
			END_IF
			ELSE
				IF	JogExecute_VI  = FALSE THEN		
					CancelMove();
					JogCase :=10;
				END_IF
		END_IF
	10:	//go for auto jog reset
		IF cancelled THEN jogCase :=20; END_IF
	20: //auto Reset cycle
		IF InLimits(Out.DistancePos_PO) THEN JogCase :=30; ELSE JogCase:=95;  END_IF
	30: JogCase :=31; //10 scan delay
	31: JogCase :=32;
	32:	JogCase :=33;
	33: JogCase :=34;
	34: JogCase :=35;
	35: JogCase :=36;
	36: JogCase :=37;
	37: JogCase := 38;
	38: JogCase := 39;
	39: JogCase :=40;
	40: //send auto jog reset
		JogReset := 1;
		JogCase :=50;
	50: //wait for jog to reset
		IF JogReset=0 THEN JogCase :=90; END_IF 
	60:
	70:
	80:
	90: IF JogExecute_VI =TRUE THEN JogCase :=0; END_IF
	95: //outside of limits	
		if Reset_VI then JogCase:=90; End_if //no autoreset if outside limits
	
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="LocatePosition" Id="{8c884be8-d2df-40c5-a6b2-c71710e2bc98}">
      <Declaration><![CDATA[METHOD PUBLIC LocatePosition : Bool //determines if sensorcheck is on and working.  Enables movement
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
// Linear axis limit sensors
(*		bHigh_FI		AT %I*	: 	BOOL;
		bLow_FI			AT %I*	: 	BOOL;
		bHome_FI		AT %I*	: 	BOOL;*)
//NC limit sensor configuration
IF IN.Limit_NC_NO_CI = 0 THEN
	IF bHigh_FI =0 AND bInputBCom_FI =1 AND CW = 1 THEN	//use normally closed sensor and check inputb(-) [applies when trying to move past limit]
		cancelmove();
		CW := 0;	//require next move to be in Neg direction or CCW  //manual move will need to be used to get off limit switch check this
		//message saying that high limit as been exceeded or inputbcom is not connected
		Out.ErrorMsg_VO := 'High Limit reached, reset and move away from limit';
	END_IF
	IF bLow_FI =0 AND bInputBCom_FI = 0 AND CW =0 THEN	//use normally closed sensor and check inputb(-) [applies when trying to move past limit]
		cancelmove();
		CW :=1;	//require next move to be in Neg direction or CCW //manual move will need to be used to get off limit switch check this
		//message saying that Low limit as been exceeded or inputbcom is not connected
		Out.ErrorMsg_VO := 'Low Limit reached, reset and move away from limit';
	END_IF
ELSE
	//NO limit sensor configuration
	//additional option to use a N/O sensor if desired....not suggested
	IF bHigh_FI =1 AND bInputBCom_FI =1 AND CW = 1 THEN	//use normally closed sensor and check inputb(-) [applies when trying to move past limit]
		cancelmove();
		CW := 0;	//require next move to be in Neg direction or CCW  //manual move will need to be used to get off limit switch check this
		//message saying that high limit as been exceeded or inputbcom is not connected
		Out.ErrorMsg_VO := 'High Limit reached, reset and move away from limit';
	END_IF
	IF bLow_FI =1 AND bInputBCom_FI = 0 AND CW =0 THEN	//use normally closed sensor and check inputb(-) [applies when trying to move past limit]
		cancelmove();
		CW :=1;	//require next move to be in Neg direction or CCW //manual move will need to be used to get off limit switch check this
		//message saying that Low limit as been exceeded or inputbcom is not connected
		Out.ErrorMsg_VO := 'Low Limit reached, reset and move away from limit';
	END_IF
END_IF
Out.LastDistancePos_PO := Out.DistancePos_PO;]]></ST>
      </Implementation>
    </Method>
    <Method Name="MechDrive_CI" Id="{cd869c98-5d3d-47c3-9a1f-8604073492a9}">
      <Declaration><![CDATA[METHOD PUBLIC MechDrive_CI : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// 0: motor only(rot), 1: Motor and gear(rot), 2: Motor w/gear and screw(lin), 3: Motor w/screw only(lin), 4: Motor w/gear and pulley(lin),  5: Motor w/pulley(lin), 8: bypass mode
(*		DistPerMRev_CI		:	INT;	//distance traveled per rev		(Calculate your own pitch and lead w/gearbox combo must set MechDriveType_CI to 8 to bypass internal calc)
		DegPerMRev_CI		:	INT;	//distance traveled per rev		(Calculate your own pitch and lead w/gearbox combo must set MechDriveType_CI to 8 to bypass internal calc)
		DisPerFPulley_CI	:	INT;	//distance traveled per rev of final pulley (mm)
		GearRatio_CI		:	INT;	// GearRatio motor to moving part (XX:1) (gearbox and lead included in calc for vert axis) (use this for gearbox and pulleys as well)
		Lead_CI				:	INT;	// Lead of Screw if used (mm)			 (gearbox and lead included in calc for vert axis)	
*)

IF IN.MechDriveType_CI = 2 THEN	//2: Motor w/gear and screw(lin)
	DistPerMRev := IN.Lead_CI/IN.GearRatio_CI;	//driven mech ex 4mm/40 = .1mm per rev
	Out.MechTypeMsg_VO := 'Motor w/gear ratio and screw - no Degrees available [no rotary by default]';
	IF IN.GearRatio_CI <=0 OR IN.Lead_CI <=0 THEN
		isconfigured :=0;
		Out.MechTypeMsg_VO := 'GearRatio_CI or Lead_CI not configured please configure to continue';
	END_IF
END_IF

IF IN.MechDriveType_CI = 3 THEN	//3: Motor w/screw only(lin)
	DistPerMRev := IN.Lead_CI;		//driven mech ex 4mm = 4mm per rev
	Out.MechTypeMsg_VO := 'Motor w/screw - no Degrees available [no rotary by default]';
	IF IN.Lead_CI <=0 THEN
		isconfigured :=0;
		Out.MechTypeMsg_VO := 'Lead_CI not configured please configure to continue';
	END_IF
END_IF

IF IN.MechDriveType_CI = 4 THEN	//4: Motor w/gear and pulley(lin),
	DistPerMRev := IN.DisPerFPulley_CI/IN.GearRatio_CI;	//pulley circumference (20t at10 ~ 200mm per fin rev/gear ratio (40) = 5mm/motor rev
	Out.MechTypeMsg_VO := 'Motor w/gear ratio and pulley [no Degree used by default (linear pulley drive) if a rotary either use bypass or use type 1 and include pulley in gear ratio]';
	IF IN.GearRatio_CI <=0 OR IN.DisPerFPulley_CI <=0 THEN
		isconfigured :=0;
		Out.MechTypeMsg_VO := 'GearRatio_CI or DisPerFPulley_CI not configured please configure to continue';
	END_IF
END_IF

IF IN.MechDriveType_CI = 5 THEN	//5: Motor w/pulley(lin);
	DistPerMRev := IN.DisPerFPulley_CI;	//pulley circumference (20t at10 ~ 200mm per fin rev/gear ratio (40) = 5mm/motor rev
	Out.MechTypeMsg_VO := 'Motor w/pulley [no Degree used by default (linear pulley drive) if a rotary either use bypass or use type 1 and include pulley in gear ratio]';
	IF IN.DisPerFPulley_CI <=0 THEN
		isconfigured :=0;
		Out.MechTypeMsg_VO := 'DisPerFPulley_CI not configured please configure to continue';
	END_IF
END_IF

IF IN.MechDriveType_CI = 8 THEN	//8 mechdrivetype is bypassed and is set via DistPerMRev_CI or DegPerMRev_CI;
	DistPerMRev := IN.DistPerMRev_CI;
	Out.MechTypeMsg_VO := 'MechDriveType is bypassed - use DegPerMRev_CI or DistPerMRev_CI';
	IF IN.DistPerMRev_CI <=0  THEN
		isconfigured :=0;
		Out.MechTypeMsg_VO := 'DistPerMRev_CI not configured please configure to continue';
	END_IF
END_IF

IF IN.InputFilter_CI <=0 THEN
	isconfigured :=0;
	Out.ConfigMSG_VO := 'Input filter not configured, please check InputFilter_CI and clearpath motor settings';
END_IF

//linear axis
DisPerPulse := (DistPerMRev*IN.cntpulseSet_CI/32000);	//check this (Likely not a correct calc)
isConfigured :=1;	//sets configuration to true so that this block only runs once]]></ST>
      </Implementation>
    </Method>
    <Method Name="MoveAbsLin" Id="{e84a9380-e5aa-4b98-914c-eeac78c6c6f8}">
      <Declaration><![CDATA[METHOD PUBLIC MoveAbsLin : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF Out.Homed_PO THEN
	CASE PositionCase OF
		0:
			IF ABS(out.DistancePos_PO-LastDistancePosReq) <in.MoveABSTol_CI THEN
				Out.InTargetPosition:=1; ELSE Out.InTargetPosition :=0;
			END_IF
		10: PositionCase :=20;
		20: PositionCase :=30;
		30: PositionCase :=40;
		40: PositionCase :=50;
		50: PositionCase :=90;
		90: PositionCase :=0;
	END_CASE
	IF ABS(VEReq - Out.DistancePos_PO) < In.MoveABSTol_CI THEN
		Out.InMPos :=1; ELSE Out.InMPos:=0;
	END_IF
	IF bMoveTrig.Q THEN Out.InMPos :=0; END_IF //Set the MPos to false after move command
END_IF
IF Out.Homed_PO THEN
	CASE DisToGoCase OF
		0:	//Readyto Take Command
			IF ABS(out.DistancePos_PO-Out.ExpDistancePos_PO) < In.MoveABSTol_CI THEN Out.InPosition:=1; END_IF	//check if current pos is within tolerance
			IF Out.InPosition THEN Out.ReadyForMove_PO :=1; END_IF		//Only ready if in position
			IF Out.ReadyForMove_PO THEN
				IF bMove_PI AND InLimits(DistancePosReq_PI)THEN  //If move is within set limits and called in Prog then execute move
					DisToGoCase :=10;
					//set MCode Received Bit [Confirm acted in end case] (this is important for aux axis in cnc VE Variable calls)
				END_IF
			END_IF
		10: //check what quePulseDistance should be and set it 
			PulsesToSend := REAL_TO_INT((DistancePosReq_PI -Out.DistancePos_PO)/In.DisPerPulse_CI); //Gets number of pulses to send
			IF PulsesToSend >0 THEN CWABS:=1; ELSE CWABS:=0; END_IF 	//Sets direction for pulses (pos CW[true] neg CW[False]
			bMove_PI :=0;	//Set Req back to false
			LastDistancePosReq := DistancePosReq_PI; //set for target
			Out.ReadyForMove_PO:=0;	//set busy with abs move
			DisToGoCase :=20;
		20: //set the if homed statement for direction control set that here and move to next case
			IF CWABS THEN CW:=1; ELSE CW:=0; END_IF	//Check abs direction each round of pulse send
			IF ABS(PulsesToSend) >0 THEN 
				PulsesEnabled:=1; 
				ELSE 	PulsesEnabled :=0; 	DisToGoCase :=30; //if no more pulses move on to case 30 to check the location tolerance
			END_IF	//if any pos or neg pulses then enable pulses
			Out.InPosition :=0;
			IF PulsesEnabled =1 AND Stop_PI = 0 AND EnableOut_FO =1 AND CW = bInputBCom_FI THEN	//check for the motor being on before incrementing the distancepos from disreq	
				//if inputA is hi then turn off (takes 2 cycles to output an increment at cp motor)
				IF CW = CWABS THEN
					SendPulse();	
					ELSE //Message CW Not equal CWABS
				END_IF	
			ELSE
				error := 5; //check the inputbcom_FI feedback
			END_IF	
			//if input filter of clearpath is too high sometimes these pulses will not register (needed to maintain ability to chain moves)  Otherwise can use asg and movedone
		30: //count pulses and and when enough pulses set pulses(rounded) not enabled set moving tag
			IF ABS(out.DistancePos_PO-DistancePosReq_PI) < In.MoveABSTol_CI THEN
				Out.InPosition:=1; Out.ABSMoveMsg_VO:='In Position';//Position Reached flag and msg
				DisToGoCase := 40;
				ELSE DisToGoCase :=99; //error
			END_IF
			DisToGoCase :=40;
		40: // ready to receive next quedistance
			Out.ReadyForMove_PO :=1;
			//Send MCode confirmation to true
			DisToGoCase:=0;
	END_CASE
	(*
	IF (DistancePosReq_PI +1) >= (QuePulseDistance + Out.DistancePos_PO) AND (DistancePosReq_PI-1)  >= (QuePulseDistance + Out.DistancePos_PO)  THEN 
		PulsesEnabled :=0;
		CW := CW;
		ELSE
			PulsesEnabled := 1;
	END_IF *)
END_IF






(*
IF InLimits(DistancePosReq_PI) AND Out.Homed_PO =1 THEN //begin pulses
	IF PulsesEnabled =1 AND Stop_PI = 0 AND EnableOut_FO =1 AND CW = bInputBCom_FI THEN	//check for the motor being on before incrementing the distancepos from disreq	
		//if inputA is hi then turn off (takes 2 cycles to output an increment at cp motor)
		SendPulse();		
		ELSE
			error := 5;
		END_IF	
		//if input filter of clearpath is too high sometimes these pulses will not register (needed to maintain ability to chain moves)  Otherwise can use asg and movedone
	IF DistancePosReq_PI = Out.ExpDistancePos_PO AND MoveComplete =0 THEN 
		PulsesEnabled :=0; 
			//check this
	END_IF
ELSE
	//message not in limits	
END_IF
//add limits option here for stopping overtravel
*)]]></ST>
      </Implementation>
    </Method>
    <Method Name="MoveDone" Id="{65827adc-0d13-4c2f-bdde-ed00c6e8e9a4}">
      <Declaration><![CDATA[METHOD PUBLIC MoveDone : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//ppr setting of hlfb is required
(*movecomplete is set either when pulsecount lines up exactly or if pulseque is empty and pulsecount is within tolerance*)
	IF PulseCount = expectedPulse  THEN	// (check this - add a tolerance here)
		MoveComplete :=1; 
		MoveDone := TRUE;
		busy :=0;			//set busy to zero (these are possibly interchangable until further code added) check this
		ELSE
			MoveDone :=FALSE;
		//is movedone() not completed check this
		//Add in MOVEDONE:=True; check this
	END_IF
	//movecomplete set for absolute move ppr tolerance
	IF PulseQueSet = 1 and PulseQue = 0 AND (pulseCount >= ExpectedPulse -2 OR PulseCount <= ExpectedPulse +2) THEN
		MoveComplete :=1;
		PulseQueSet :=0;
		MoveDone := TRUE;
		Busy :=0;
		//set expected to pulscount?
		//expectedPulse := PulseCount;
	END_IF
(* set DistPos_PO based off pulsecount/pulsecountset_ci  then check expectedDistPos_PO against current *)
//check busy and move complete in asg and if busytrig then check asgtrig then set move complete
 ]]></ST>
      </Implementation>
    </Method>
    <Method Name="PPR" Id="{8a91c23a-12e7-4d5e-91dc-5686f1305db6}">
      <Declaration><![CDATA[METHOD PUBLIC PPR : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF PulseCounter.Q THEN
	IF InputBOut_FO =1 THEN
		PulseCount := PulseCount +1;
		ELSE
			PulseCount := PulseCount -1;
		END_IF
		//extra pulse after homing is happening here? check this
END_IF

IF ATrig.Q AND Cancelled = 0 THEN
	IF InputBOut_FO = 1 THEN 
		ExpectedPulse := ExpectedPulse + (1*IN.PPRset_CI); //does not account for cnt per rev yet
		PulsesToSend := PulsesToSend-1;			//Track ABS Pulses sent  [went pos dir so remove one from que]
		ELSE 
			ExpectedPulse := ExpectedPulse - (1*IN.PPRset_CI);
			PulsesToSend := PulsesToSend +1;	//Track ABS Pulses sent  [went neg dir so add one from que]
	END_IF
	//expectedpulse should be 32000cnts div by ppr = cnts per pulse
	//expectedPulse should be cntset_CI/320000 *(1*pprset_ci)   //30223cnts per pulse currently
END_IF
IF HomeTrig.Q THEN
	PulseCount  :=0;	//set position to zero after homing is complete
	ExpectedPulse := 0;
END_IF
IF Cancelled = 1 THEN
	expectedPulse := pulsecount;
END_IF
IF  movecomplete = 1 THEN //ppr mode
	 Out.DistancePos_PO := PulseCount/2; //change distancePOs_PO to float if needed
	 Out.ExpDistancePos_PO := PulseCount/2;
END_IF
IF  PowerOn_PI =0 THEN
	Out.DistancePos_PO := PulseCount/2; //change distancePOs_PO to float if needed	//resets DistancePos_PO if PowerOn_PI signal is interupted or turned off after if mid move
	 Out.ExpDistancePos_PO := PulseCount/2;
END_IF
Out.DistancePos_PO := PulseCount/2; //change distancePOs_PO to float if needed 
(* if expected pulses are in tolerance then pulsecount/ pprset should be used to set new dist position   
*)]]></ST>
      </Implementation>
    </Method>
    <Method Name="Reset" Id="{2f333321-886a-47c6-a284-16098127d303}">
      <Declaration><![CDATA[METHOD PUBLIC Reset : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE ResetCase OF
	0:
		IF reset_VI =1 OR JogReset=1 THEN
			EnableOut_FO :=0;	//Turn off to reset (power on will finish reset)
			Cancelled :=0;	//reset the cancelled move bit
			busy :=0;	// check this (is reseting busy needed?)
			DisToGoCase:=0;
			ResetCase :=10;
			OUt.MechTypeMsg_VO 		:= '';		
			Out.ConfigMSG_VO		:= '';		
			Out.ErrorMsg_VO			:= '';	
			Out.Error2Msg_VO		:= '';	
			Out.Error3Msg_VO		:='';		
			Out.Error4Msg_VO 		:='';
			Out.HomeMsg_VO 			:='';				
			OUt.LimitsMsg_VO		:='';	
			Out.ABSMoveMsg_VO		:='';
			OUt.SuperJogMsg_VO		:='';
			Out.DisToGoMsg_VO		:='';
			Out.CanceledMsg_VO		:='';
			Out.ModeMsg_VO			:='';
			LastDistanceposReq := Out.DistancePos_PO;
		END_IF
	(*original section above for manual reset *)
	10: ResetCase:=20;
	20: ResetCase:=30;
	30: ResetCase:=40;
	40: ResetCase:=50;
	50: ResetCase:=60;
	60: ResetCase:=70;
	70: ResetCase:=80;
	80: ResetCase:=90;
	90: 
		ResetCase:=0;
		Reset_Vi:=0;
		JogReset:=0;
END_CASE
//reset by turning power off and then on]]></ST>
      </Implementation>
    </Method>
    <Method Name="SendPulse" Id="{16480c75-95b5-4bde-bc97-a39b3e55a8bf}">
      <Declaration><![CDATA[METHOD PUBLIC SendPulse : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//got rid of 'and busy =0'
IF Stop_PI = 0  AND EnableOut_FO =1 AND CW = bInputBCom_FI THEN	//check for the motor being on before incrementing the distancepos from disreq	
	IF InputAOut_FO =1  THEN 
		InputAOut_FO := 0;
	ELSE 
		IF AltSpeedReq THEN
			IF AltspeedCase =60 THEN
				InputAOut_FO :=1;		//else turn true and subtract increment counter
				AltspeedCase :=0;	//reset altspeed
				IF CW =1 THEN Out.ExpDistancePos_PO := Out.ExpDistancePos_PO +1; ELSE Out.ExpDistancePos_PO := Out.ExpDistancePos_PO - 1; END_IF
			END_IF
		ELSE
			InputAOut_FO :=1;		//else turn true and subtract increment counter
			IF CW =1 THEN Out.ExpDistancePos_PO := Out.ExpDistancePos_PO +1; ELSE Out.ExpDistancePos_PO := Out.ExpDistancePos_PO - 1; END_IF
		END_IF
		MoveComplete :=0;		//set movedone to zero and await move complete
		busy		 :=1;		//set status to busy until move complete
	END_IF	
ELSE
	//InputAOut_FO := 0;		//no trigger if stopped or direction feedback failed or if motor enable is off
	//Message Saying Move is in progress
	Error:=3;//chck inputbCom feedback
		
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="SuperJog" Id="{7beb6e07-8c5b-4751-91a5-b0de2d7772ab}">
      <Declaration><![CDATA[METHOD PUBLIC SuperJog : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//using this mode will disable the two sensor safety check for manual manual mode
//homing is not required to use this and as such should be used with caution
//if not 2 sensors on and not in super mode then no movement allowed
	
	//message : at least one sensor is down please check sensors.  if movement is needed enter supermanual mode
	
//else  allow manual mode  even if not all sensors are working
	//message: you are in supermanual mode and will bypass anti collision devices.  please take caution
//add software limits check this

//add software limits check this
CASE SuperJogCase OF 
	0:	//Main Jog Sequence [Also stops movement]
		IF JogSlow_VI THEN AltspeedReq :=1; ELSE AltSpeedReq :=0;   END_IF
			
		IF SuperJogExecute_VI  THEN	//if last move is done then allow for manual increment also required to be at home //check sensor check
			(*IF IN.Limit_NC_NO_CI = 0 THEN	//NC limit switch configuration
				IF bHigh_FI AND bLow_FI THEN //set direction via hmi unless on a limit switch then default to locateposition()
					IF CW_VI = 1 	THEN	CW := 1; 	ELSE CW:=0; 	END_IF
					IF bhigh_fI = 0	THEN 	CW:=0; 		END_IF
					IF bLow_FI = 0 	THEN 	CW:=1; 		END_IF
				END_IF
				ELSE	//NO limit switch configuration
					IF bHigh_FI =0 AND bLow_FI  = 0 THEN //set direction via hmi unless on a limit switch then default to locateposition()
					IF CW_VI = 1 	THEN	CW := 1; 	ELSE CW:=0; 	END_IF
					IF bhigh_fI = 1	THEN 	CW:=0; 		END_IF
					IF bLow_FI = 1 	THEN 	CW:=1; 		END_IF
				END_IF
			END_IF*)
			IF CW_VI = 1 	THEN	CW := 1; 	ELSE CW:=0; 	END_IF
			IF AltspeedReq THEN			// slowjog if altspeed is requested and wait for case 60
				IF AltspeedCase = 60 THEN
					SendPulse();
					
				END_IF
				ELSE
					SendPulse();		//send pulse for reg speed jog
			END_IF
			ELSE
				IF	SuperJogExecute_VI  = FALSE THEN		
					CancelMove();
					SuperJogCase :=10;
				END_IF
		END_IF
	10:	//
		IF SuperJogExecute_VI =TRUE THEN SuperJogCase :=0; END_IF
		
	
END_CASE]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="ClearpathPositionLinPPR">
      <LineId Id="2508" Count="4" />
      <LineId Id="2747" Count="0" />
      <LineId Id="2782" Count="0" />
      <LineId Id="2748" Count="0" />
      <LineId Id="2783" Count="2" />
      <LineId Id="2787" Count="0" />
      <LineId Id="2789" Count="3" />
      <LineId Id="2795" Count="0" />
      <LineId Id="2793" Count="0" />
      <LineId Id="2796" Count="0" />
      <LineId Id="2746" Count="0" />
      <LineId Id="2513" Count="1" />
      <LineId Id="2781" Count="0" />
      <LineId Id="2520" Count="2" />
      <LineId Id="2529" Count="1" />
      <LineId Id="3095" Count="0" />
      <LineId Id="2531" Count="1" />
      <LineId Id="3100" Count="0" />
      <LineId Id="3520" Count="0" />
      <LineId Id="3419" Count="1" />
      <LineId Id="3423" Count="0" />
      <LineId Id="3425" Count="0" />
      <LineId Id="3428" Count="0" />
      <LineId Id="3422" Count="0" />
      <LineId Id="3101" Count="0" />
      <LineId Id="3429" Count="0" />
      <LineId Id="3431" Count="0" />
      <LineId Id="3430" Count="0" />
      <LineId Id="3098" Count="0" />
      <LineId Id="3196" Count="0" />
      <LineId Id="2533" Count="0" />
      <LineId Id="2788" Count="0" />
      <LineId Id="2536" Count="1" />
      <LineId Id="2541" Count="0" />
      <LineId Id="228" Count="0" />
    </LineIds>
    <LineIds Name="ClearpathPositionLinPPR.AltSpeed">
      <LineId Id="6" Count="1" />
      <LineId Id="5" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="8" Count="0" />
      <LineId Id="50" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="43" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="44" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="46" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="40" Count="0" />
      <LineId Id="48" Count="0" />
      <LineId Id="53" Count="0" />
      <LineId Id="52" Count="0" />
      <LineId Id="28" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="14" Count="0" />
    </LineIds>
    <LineIds Name="ClearpathPositionLinPPR.CancelMove">
      <LineId Id="18" Count="2" />
      <LineId Id="27" Count="2" />
      <LineId Id="37" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="21" Count="2" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="ClearpathPositionLinPPR.DisToGo">
      <LineId Id="19" Count="0" />
      <LineId Id="6" Count="0" />
      <LineId Id="8" Count="5" />
      <LineId Id="37" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="14" Count="1" />
      <LineId Id="29" Count="0" />
      <LineId Id="46" Count="1" />
      <LineId Id="31" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="20" Count="1" />
      <LineId Id="23" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="35" Count="0" />
      <LineId Id="34" Count="0" />
    </LineIds>
    <LineIds Name="ClearpathPositionLinPPR.Enable">
      <LineId Id="22" Count="1" />
      <LineId Id="48" Count="2" />
      <LineId Id="24" Count="1" />
      <LineId Id="40" Count="0" />
      <LineId Id="42" Count="0" />
      <LineId Id="27" Count="4" />
      <LineId Id="18" Count="0" />
    </LineIds>
    <LineIds Name="ClearpathPositionLinPPR.Error">
      <LineId Id="6" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="ClearpathPositionLinPPR.Home">
      <LineId Id="106" Count="0" />
      <LineId Id="231" Count="6" />
      <LineId Id="67" Count="0" />
      <LineId Id="69" Count="0" />
      <LineId Id="253" Count="1" />
      <LineId Id="70" Count="1" />
      <LineId Id="239" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="137" Count="0" />
      <LineId Id="242" Count="7" />
      <LineId Id="241" Count="0" />
      <LineId Id="151" Count="0" />
      <LineId Id="202" Count="1" />
      <LineId Id="240" Count="0" />
      <LineId Id="226" Count="1" />
      <LineId Id="224" Count="0" />
      <LineId Id="250" Count="0" />
      <LineId Id="204" Count="0" />
      <LineId Id="143" Count="0" />
      <LineId Id="139" Count="0" />
      <LineId Id="225" Count="0" />
      <LineId Id="154" Count="0" />
      <LineId Id="157" Count="0" />
      <LineId Id="166" Count="0" />
      <LineId Id="267" Count="0" />
      <LineId Id="167" Count="2" />
      <LineId Id="268" Count="0" />
      <LineId Id="271" Count="1" />
      <LineId Id="270" Count="0" />
      <LineId Id="269" Count="0" />
      <LineId Id="171" Count="1" />
      <LineId Id="258" Count="1" />
      <LineId Id="188" Count="0" />
      <LineId Id="228" Count="0" />
      <LineId Id="190" Count="0" />
      <LineId Id="217" Count="0" />
      <LineId Id="199" Count="0" />
      <LineId Id="260" Count="0" />
      <LineId Id="263" Count="3" />
      <LineId Id="261" Count="1" />
      <LineId Id="200" Count="1" />
      <LineId Id="152" Count="0" />
      <LineId Id="218" Count="0" />
      <LineId Id="221" Count="0" />
      <LineId Id="223" Count="0" />
      <LineId Id="140" Count="0" />
      <LineId Id="206" Count="0" />
      <LineId Id="209" Count="0" />
      <LineId Id="212" Count="3" />
      <LineId Id="252" Count="0" />
      <LineId Id="216" Count="0" />
      <LineId Id="205" Count="0" />
      <LineId Id="141" Count="1" />
      <LineId Id="138" Count="0" />
    </LineIds>
    <LineIds Name="ClearpathPositionLinPPR.InLimits">
      <LineId Id="24" Count="5" />
      <LineId Id="43" Count="4" />
      <LineId Id="41" Count="0" />
    </LineIds>
    <LineIds Name="ClearpathPositionLinPPR.Jog">
      <LineId Id="143" Count="0" />
      <LineId Id="40" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="203" Count="0" />
      <LineId Id="227" Count="0" />
      <LineId Id="235" Count="0" />
      <LineId Id="210" Count="0" />
      <LineId Id="241" Count="0" />
      <LineId Id="211" Count="4" />
      <LineId Id="242" Count="0" />
      <LineId Id="244" Count="3" />
      <LineId Id="243" Count="0" />
      <LineId Id="240" Count="0" />
      <LineId Id="228" Count="1" />
      <LineId Id="231" Count="0" />
      <LineId Id="236" Count="0" />
      <LineId Id="232" Count="2" />
      <LineId Id="230" Count="0" />
      <LineId Id="217" Count="0" />
      <LineId Id="219" Count="1" />
      <LineId Id="222" Count="0" />
      <LineId Id="221" Count="0" />
      <LineId Id="209" Count="0" />
      <LineId Id="205" Count="0" />
      <LineId Id="272" Count="0" />
      <LineId Id="251" Count="20" />
      <LineId Id="223" Count="0" />
      <LineId Id="276" Count="0" />
      <LineId Id="208" Count="0" />
      <LineId Id="204" Count="0" />
    </LineIds>
    <LineIds Name="ClearpathPositionLinPPR.LocatePosition">
      <LineId Id="56" Count="0" />
      <LineId Id="59" Count="0" />
      <LineId Id="63" Count="1" />
      <LineId Id="62" Count="0" />
      <LineId Id="53" Count="0" />
      <LineId Id="96" Count="0" />
      <LineId Id="60" Count="0" />
      <LineId Id="65" Count="0" />
      <LineId Id="67" Count="0" />
      <LineId Id="72" Count="0" />
      <LineId Id="77" Count="0" />
      <LineId Id="66" Count="0" />
      <LineId Id="69" Count="2" />
      <LineId Id="73" Count="0" />
      <LineId Id="78" Count="0" />
      <LineId Id="68" Count="0" />
      <LineId Id="97" Count="0" />
      <LineId Id="82" Count="1" />
      <LineId Id="85" Count="10" />
      <LineId Id="84" Count="0" />
      <LineId Id="99" Count="1" />
    </LineIds>
    <LineIds Name="ClearpathPositionLinPPR.MechDrive_CI">
      <LineId Id="62" Count="6" />
      <LineId Id="80" Count="1" />
      <LineId Id="83" Count="1" />
      <LineId Id="114" Count="2" />
      <LineId Id="113" Count="0" />
      <LineId Id="85" Count="2" />
      <LineId Id="89" Count="1" />
      <LineId Id="118" Count="2" />
      <LineId Id="117" Count="0" />
      <LineId Id="91" Count="2" />
      <LineId Id="95" Count="1" />
      <LineId Id="122" Count="2" />
      <LineId Id="121" Count="0" />
      <LineId Id="97" Count="2" />
      <LineId Id="101" Count="1" />
      <LineId Id="126" Count="2" />
      <LineId Id="125" Count="0" />
      <LineId Id="103" Count="2" />
      <LineId Id="107" Count="1" />
      <LineId Id="134" Count="2" />
      <LineId Id="133" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="141" Count="0" />
      <LineId Id="140" Count="0" />
      <LineId Id="144" Count="0" />
      <LineId Id="142" Count="1" />
      <LineId Id="151" Count="1" />
      <LineId Id="156" Count="0" />
      <LineId Id="160" Count="0" />
    </LineIds>
    <LineIds Name="ClearpathPositionLinPPR.MoveAbsLin">
      <LineId Id="119" Count="1" />
      <LineId Id="122" Count="0" />
      <LineId Id="130" Count="2" />
      <LineId Id="124" Count="5" />
      <LineId Id="123" Count="0" />
      <LineId Id="138" Count="2" />
      <LineId Id="137" Count="0" />
      <LineId Id="121" Count="0" />
      <LineId Id="61" Count="14" />
      <LineId Id="133" Count="0" />
      <LineId Id="76" Count="38" />
      <LineId Id="55" Count="5" />
      <LineId Id="39" Count="0" />
      <LineId Id="6" Count="0" />
      <LineId Id="8" Count="1" />
      <LineId Id="50" Count="0" />
      <LineId Id="22" Count="2" />
      <LineId Id="26" Count="2" />
      <LineId Id="49" Count="0" />
      <LineId Id="30" Count="3" />
      <LineId Id="5" Count="0" />
      <LineId Id="115" Count="0" />
    </LineIds>
    <LineIds Name="ClearpathPositionLinPPR.MoveDone">
      <LineId Id="19" Count="0" />
      <LineId Id="49" Count="0" />
      <LineId Id="6" Count="1" />
      <LineId Id="42" Count="3" />
      <LineId Id="36" Count="1" />
      <LineId Id="5" Count="0" />
      <LineId Id="52" Count="1" />
      <LineId Id="56" Count="5" />
      <LineId Id="55" Count="0" />
      <LineId Id="46" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="28" Count="0" />
    </LineIds>
    <LineIds Name="ClearpathPositionLinPPR.PPR">
      <LineId Id="6" Count="5" />
      <LineId Id="37" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="13" Count="1" />
      <LineId Id="54" Count="0" />
      <LineId Id="49" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="52" Count="1" />
      <LineId Id="28" Count="0" />
      <LineId Id="21" Count="1" />
      <LineId Id="15" Count="2" />
      <LineId Id="26" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="35" Count="0" />
      <LineId Id="43" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="40" Count="1" />
      <LineId Id="44" Count="0" />
      <LineId Id="42" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="32" Count="0" />
    </LineIds>
    <LineIds Name="ClearpathPositionLinPPR.Reset">
      <LineId Id="46" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="49" Count="3" />
      <LineId Id="61" Count="0" />
      <LineId Id="54" Count="0" />
      <LineId Id="62" Count="0" />
      <LineId Id="56" Count="4" />
      <LineId Id="48" Count="0" />
      <LineId Id="70" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="34" Count="10" />
      <LineId Id="33" Count="0" />
      <LineId Id="66" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="16" Count="0" />
    </LineIds>
    <LineIds Name="ClearpathPositionLinPPR.SendPulse">
      <LineId Id="24" Count="0" />
      <LineId Id="6" Count="4" />
      <LineId Id="20" Count="0" />
      <LineId Id="11" Count="1" />
      <LineId Id="28" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="22" Count="1" />
      <LineId Id="27" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="14" Count="1" />
      <LineId Id="17" Count="2" />
      <LineId Id="26" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="ClearpathPositionLinPPR.SuperJog">
      <LineId Id="5" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="6" Count="0" />
      <LineId Id="9" Count="1" />
      <LineId Id="16" Count="0" />
      <LineId Id="8" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="83" Count="0" />
      <LineId Id="100" Count="19" />
      <LineId Id="138" Count="0" />
      <LineId Id="120" Count="17" />
      <LineId Id="60" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>